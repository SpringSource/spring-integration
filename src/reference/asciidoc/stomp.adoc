[[stomp]]
== STOMP Support

[[stomp-introduction]]
=== Introduction

Starting with _version 4.2_ Spring Integration has introduced _STOMP Client_ support.
It is based on architecture, infrastructure and API from the Spring Framework's _messaging_ module, _stomp_ package.
Therefore, many of Spring STOMP components (e.g. `StompSession` or `StompClientSupport`)
can be reused within Spring Integration.
For more information, please, refer to http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp-client[Spring Framework STOMP Support]
chapter in the Spring Framework reference manual.

[[stomp-overview]]
=== Overview

Even if STOMP is the Simple (or Streaming) Text Orientated Messaging Protocol, we need to do some configuration steps
to make our integration interaction with the target STOMP Broker.
First of all we should start from the _STOMP Client_ object.
The Spring Framework provides these implementations:

* `WebSocketStompClient` - built on the Spring WebSocket API with support for standard JSR-356 WebSocket, Jetty 9,
as well as SockJS for HTTP-based WebSocket emulation with SockJS Client.

* `Reactor2TcpStompClient` - built on `NettyTcpClient` from the `reactor-net` project.

Any other `StompClientSupport` implementation can be provided.
See the JavaDocs of those classes for more information.

The `StompClientSupport` is designed as a _factory_ to produce `StompSession` for the provided
`StompSessionHandler` and all the rest "hard" STOMP work is done through the _callbacks_ to that `StompSessionHandler`
and `StompSession` abstraction.
It is useful and convenient in the raw stateless Java program, but with the Spring Integration _adapter_ abstraction we
should supply some managed shared object to represent our application as a STOMP client with its unique session.
For this purpose the Spring Integration is introducing the `StompSessionManager` abstraction to manage the _single_
`StompSession` between any provided `StompSessionHandler`.
This helps us to have one of _inbound_ or _outbound_ channel adapters or both for the particular STOMP Broker.
See `StompSessionManager` (and its implementations) JavaDocs for more information.

[[stomp-inbound-adapter]]
=== STOMP Inbound Channel Adapter

The `StompInboundChannelAdapter` is the one-stop `MessageProducer` component to subscribe our Spring Integration
application to the provided STOMP destinations and receive messages from them, converted from the STOMP
frames using the provided `MessageConverter` on the connected `StompSession`.
The destinations (and therefore STOMP subscriptions) can be changed at runtime using appropriate `@ManagedOperation` s
on the `StompInboundChannelAdapter`.

For more configuration options see <<stomp-namespace>> and `StompInboundChannelAdapter` JavaDocs.

[[stomp-outbound-adapter]]
=== STOMP Outbound Channel Adapter

The `StompMessageHandler` represents the `MessageHandler` for the `<int-stomp:outbound-channel-adapter>`
to send the incoming `Message<?>` s to the pre-configured or determined at runtime (via the SpEL expression) STOMP
`destination` through the `StompSession`, provided by the shared `StompSessionManager`.

For more configuration option see <<stomp-namespace>> and `StompMessageHandler` JavaDocs.

[[stomp-headers]]
=== STOMP Headers Mapping

The STOMP protocol provides the _headers_ concept as part of frame, therefore the entire structure of the STOMP frame
looks like:

....
COMMAND
header1:value1
header2:value2

Body^@
....

From other it would be useful to have possibility to interact with STOMP protocol from/to Messaging smoothly.
For this purpose Spring Framework introduces `StompHeaders`, where, according to its JavaDocs, you can understand
the STOMP headers and frame (command) types relationship.
Since STOMP frames are converted to/from `Message<?>` it would be good if those `StompHeaders` are mapped to/from
`MessageHeaders`.
And Spring Integration provides its standard `HeaderMapper` implementation for the STOMP adapters as well.
The default implementation is `StompHeaderMapper` which severs `fromHeaders()` and `toHeaders()` operations for the
_inbound_ and _outbound_ adapters respectively.

In the symmetry with many other Spring Integration modules the `IntegrationStompHeaders` constant class has been
introduced to map standard STOMP headers to `MessageHeaders` with `stomp_` prefix.
As well as all those `MessageHeaders` with that prefix are mapped to the `StompHeaders` on the send-to-destination
part.

For more information see JavaDocs of those classes and `mapped-headers` attribute description in the <<stomp-namespace>>.

[[stomp-events]]
=== STOMP Integration Events Extension

Since STOMP protocol is _streaming_, many operations with it are done asynchronously, even error handling.
In addition the STOMP has a `RECEIPT` server frame as an answer to those client frames which have been requested with
the `RECEIPT` header.
To process those asynchronous events the Spring Integration introduced `StompIntegrationEvent` s to emit them to the
`ApplicationContext` for the further business logic to treat errors or react to the messages' receipts.

Specifically, `StompExceptionEvent` is emitted from the `AbstractStompSessionManager`, when
`stompSessionListenableFuture` receives `onFailure()` in case of failure to connect to STOMP Broker.
Another place is `StompMessageHandler` with its internal `StompSessionHandler.handleFrame()` implementation to process
`ERROR` STOMP frames, which are answers from the server to bad unaccepted messages sent by this `StompMessageHandler`.

The `StompReceiptEvent` s are emitted from the `StompMessageHandler` as a part of `StompSession.Receiptable`
callbacks in the asynchronous answers for the sent messages to the `StompSession`.
The `StompReceiptEvent` can be positive and negative from the perspective of receiving or not the `RECEIPT` frame
from the server during the `receiptTimeLimit` period, which can be configured on the `StompClientSupport` instance.
Defaults to `15 * 1000`.

NOTE: The `StompSession.Receiptable` callbacks are added only if the `RECEIPT` STOMP header of the message to send
isn't `null`.
The automatic `RECEIPT` header generation can be enabled on the `StompSession` through its `autoReceipt` option and
on the `StompSessionManager` respectively.

See the next paragraph for more information how to configure Spring Integration to accept those `ApplicationEvent` s.

[[stomp-java-config]]
=== STOMP Adapters Java Configuration

The comprehensive Java & Annotation Configuration for STOMP Adapters may look like this:

[source,java]
----
@Configuration
@EnableIntegration
public class StompConfiguration {

    @Bean
    public Reactor2TcpStompClient stompClient() {
        Reactor2TcpStompClient stompClient = new Reactor2TcpStompClient("127.0.0.1", 61613);
        stompClient.setMessageConverter(new PassThruMessageConverter());
        ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
        taskScheduler.afterPropertiesSet();
        stompClient.setTaskScheduler(taskScheduler);
        stompClient.setReceiptTimeLimit(5000);
        return stompClient;
    }

    @Bean
    public StompSessionManager stompSessionManager() {
        Reactor2TcpStompSessionManager stompSessionManager = new Reactor2TcpStompSessionManager(stompClient());
        stompSessionManager.setAutoReceipt(true);
        return stompSessionManager;
    }

    @Bean
    public PollableChannel stompInputChannel() {
        return new QueueChannel();
    }

    @Bean
    public StompInboundChannelAdapter stompInboundChannelAdapter() {
        StompInboundChannelAdapter adapter =
        		new StompInboundChannelAdapter(stompSessionManager(), "/topic/myTopic");
        adapter.setOutputChannel(stompInputChannel());
        return adapter;
    }

    @Bean
    @ServiceActivator(inputChannel = "stompOutputChannel")
    public MessageHandler stompMessageHandler() {
        StompMessageHandler handler = new StompMessageHandler(stompSessionManager());
        handler.setDestination("/topic/myTopic");
        return handler;
    }

    @Bean
    public PollableChannel stompEvents() {
        return new QueueChannel();
    }

    @Bean
    public ApplicationListener<ApplicationEvent> stompEventListener() {
        ApplicationEventListeningMessageProducer producer = new ApplicationEventListeningMessageProducer();
        producer.setEventTypes(StompIntegrationEvent.class);
        producer.setOutputChannel(stompEvents());
        return producer;
    }

}
----

[[stomp-namespace]]
=== STOMP Namespace Support

Spring Integration _STOMP_ namespace implements _inbound_ and _outbound_ channel adapter components described below.
To include it in your configuration, simply provide the following namespace declaration in your application context
configuration file:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:int="http://www.springframework.org/schema/integration"
  xmlns:int-stomp="http://www.springframework.org/schema/integration/stomp"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration
    http://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/stomp
    http://www.springframework.org/schema/integration/stomp/spring-integration-stomp.xsd">
    ...
</beans>
----

*<int-stomp:outbound-channel-adapter>*

[source,xml]
----
<int-stomp:outbound-channel-adapter
                           id=""  <1>
                           channel=""  <2>
                           stomp-session-manager=""  <3>
                           header-mapper=""  <4>
                           mapped-headers=""  <5>
                           destination=""  <6>
                           destination-expression=""  <7>
                           auto-startup=""  <8>
                           phase=""/>  <9>
----



<1> The component bean name.
If the `channel` attribute isn't provided, a `DirectChannel` is created and registered with the application context
with this `id` attribute as the bean name.
In this case, the endpoint is registered with the bean name `id + '.adapter'`.
And the `MessageHandler` is registered with the bean alias `id + '.handler'`.


<2> Identifies the channel attached to this adapter.


<3> The reference to the `StompSessionManager` bean, which encapsulates the low-level connection and `StompSession`
handling operations.
Required.


<4> Reference to a bean implementing `HeaderMapper<StompHeaders>` that maps Spring Integration MessageHeaders to/from
STOMP frame headers.
This is mutually exclusive with `mapped-headers`.
Defaults to `StompHeaderMapper`.


<5> Comma-separated list of names of STOMP Headers to be mapped from/to the STOMP frame headers.
This can only be provided if the `header-mapper` reference is not being set directly.
The values in this list can also be simple patterns to be matched against the header names (e.g. "foo*" or "*foo").
Special tokens `STOMP_INBOUND_HEADERS` and `STOMP_OUTBOUND_HEADERS` represent all the standard STOMP headers
(content-length, receipt, heart-beat etc) for the _inbound_ and _outbound_ channel adapters respectively;
they are included by default.
If you wish to add your own headers, you must also include these tokens if you wish the standard headers to also be
mapped or provide your own `HeaderMapper` implementation using `header-mapper`.


<6> Name of the destination to which STOMP Messages will be sent.
Mutually exclusive with the `destination-expression`.


<7> A SpEL expression to be evaluated at runtime against each Spring Integration `Message` as the root object.
Mutually exclusive with the `destination`.


<8> Boolean value indicating whether this endpoint should start automatically.
Default to `true`.


<9> The lifecycle phase within which this endpoint should start and stop.
The lower the value the earlier this endpoint will start and the later it will stop.
The default is `Integer.MIN_VALUE`.
Values can be negative.
See `SmartLifeCycle`.

*<int-stomp:inbound-channel-adapter>*

[source,xml]
----
<int-stomp:inbound-channel-adapter
                           id=""  <1>
                           channel=""  <2>
                           error-channel=""  <3>
                           stomp-session-manager=""  <4>
                           header-mapper=""  <5>
                           mapped-headers=""  <6>
                           destinations=""  <7>
                           send-timeout=""  <8>
                           payload-type=""  <9>
                           auto-startup=""  <10>
                           phase=""/>  <11>
----



<1> The component bean name.
If the `channel` attribute isn't provided, a `DirectChannel` is created and registered with the application context
with this `id` attribute as the bean name.
In this case, the endpoint is registered with the bean name `id + '.adapter'`.


<2> Identifies the channel attached to this adapter.


<3> The `MessageChannel` bean reference to which the `ErrorMessages` should be sent.


<4> See the same option on the `<int-stomp:outbound-channel-adapter>`.


<5> See the same option on the `<int-stomp:outbound-channel-adapter>`.


<6> See the same option on the `<int-stomp:outbound-channel-adapter>`.


<7> Comma-separated list of STOMP destination names to subscribe.
The list of destinations (and therefore subscriptions) can be modified at runtime
through the `addDestination() and `removeDestination()` `@ManagedOperation` s.


<8> Maximum amount of time in milliseconds to wait when sending a message to the channel if the channel may block.
For example, a `QueueChannel` can block until space is available if its maximum capacity has been reached.


<9> Fully qualified name of the java type for the target `payload` to convert from the incoming STOMP Frame.
Default to `String.class`.


<10> See the same option on the `<int-stomp:outbound-channel-adapter>`.


<11> See the same option on the `<int-stomp:outbound-channel-adapter>`.
