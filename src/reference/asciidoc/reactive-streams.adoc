[[reactive-streams]]
== Reactive Streams Support

Spring Integration provides support for https://www.reactive-streams.org/[Reactive Streams] interaction in different place of the framework and from different aspects.
We will revise most of them here with appropriate links to the target chapters for details whenever necessary.

=== Preface

To recap, the Spring Integration extends the Spring programming model to support the well-known Enterprise Integration Patterns.
Spring Integration enables lightweight messaging within Spring-based applications and supports integration with external systems via declarative adapters.
Spring Integration’s primary goal is to provide a simple model for building enterprise integration solutions while maintaining the separation of concerns that is essential for producing maintainable, testable code.
This goal is achieved in the target application using first class citizens like `message`, `channel` and `endpoint`, which allow us to build an integration flow (pipeline), where (in most cases) one endpoint produces messages into a channel to be consumed by another endpoint.
This way we distinguish an integration interaction model from the target business logic.
The crucial part here is a channel in between: the flow behavior depends from its implementation leaving endpoints untouched.

On the other hand, the Reactive Streams is a standard for asynchronous stream processing with non-blocking back pressure.
The main goal of Reactive Streams is to govern the exchange of stream data across an asynchronous boundary – like passing elements on to another thread or thread-pool – while ensuring that the receiving side is not forced to buffer arbitrary amounts of data.
In other words, back pressure is an integral part of this model in order to allow the queues which mediate between threads to be bounded.
The intention of Reactive Streams implementation, such as https://projectreactor.io/[Project Reactor], is to preserve the mentioned benefits and characteristics across the whole processing graph of a stream application.
The ultimate goal of Reactive Streams libraries is to provide types, set of operators and support API to be a target application in transparent and smooth manner as it is possible with available programming language structure, but the final solution is not so imperative as it is with a normal functions chain invocation.
It rather divided into to phases: definition and execution which happens somewhere later during subscription to the final reactive publisher and demand for data is pushed from the bottom of the definition to the top with a back-pressure manner - we request as much events as we can handle at the moment.
The reactive application looks like a `"stream"` or as we got used to in Spring Integration terms - `"stream"`.
In fact the Reactive Streams SPI since Java 9 is presented in the `java.util.concurrent.Flow` class.

From here it may look like Spring Integration flows are really a good fit for writing Reactive Streams applications when we apply some reactive framework operators on endpoints, but in fact the problems is much broader and we need to keep in mind that not all endpoints (e.g. `JdbcMessageHandler`) can be processed in reactive stream transparently.
Of course, the main goal for Reactive Streams support in Spring Integration is to allow the whole process to be fully reactive, on demand initiated and back-pressure ready.
It is not going to be possible until the target protocols and systems for channel adapters provide a Reactive Streams interaction model.
In the sections below we will describe what components and approaches are provided in Spring Integration for developing reactive application preserving integration flow structures.

=== Messaging Gateway

=== Reactive Reply Payload

=== `FluxMessageChannel` and `ReactiveStreamsConsumer`

=== Source Polling Channel Adapter

=== Splitter and Aggregator

=== Java DSL

=== Reactive Channel Adapters
