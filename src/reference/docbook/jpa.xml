<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="jpa"
	xmlns:xlink="http://www.w3.org/1999/xlink">
	<title>JPA Support</title>
	<para>
		Spring Integration's JPA (Java Persistence API) module provides components
		for performing various database operations using JPA. The following
		components are provided:
	</para>
	<itemizedlist>
		<listitem>
			<para><emphasis><link linkend='jpa-outbound-channel-adapter'>Outbound Channel adapter</link></emphasis></para>
		</listitem>
		<listitem>
			<para><emphasis><link linkend='jpa-outbound-gateway'>Outbound Gateway</link></emphasis></para>
		</listitem>
		<listitem>
			<para><emphasis><link linkend='jpa-inbound-channel-adapter'>Inbound Channel Adapter</link></emphasis></para>
		</listitem>
	</itemizedlist>
	<para>
		These components can be used to perform
		<emphasis>select</emphasis>,
		<emphasis>create</emphasis>,
		<emphasis>update</emphasis> and
		<emphasis>delete</emphasis>
		operations on the targeted database by sending/receiving messages to them.
	</para>
	<para>
		The above operations can be performed using either of the
		following:
	</para>
	<itemizedlist>
		<listitem>
			<para><emphasis>Entity classes</emphasis></para>
		</listitem>
		<listitem>
			<para>
				<emphasis>
					Java Persistence Query Language (JPQL) for update, select and
					delete (inserts are not supported by JPQL)
				</emphasis>
			</para>
		</listitem>
		<listitem>
			<para><emphasis>Native query</emphasis></para>
		</listitem>
		<listitem>
			<para><emphasis>Named query</emphasis></para>
		</listitem>
	</itemizedlist>
	<para>
		In the following sections we will describe each of these components in
		more detail.
	</para>
	<section id="jpa-supported-persistence-providers">
		<title>Supported Persistence Providers</title>
		<para>
			The Spring Integration JPA support is being tested using the following
			persistence providers:
		</para>
		<itemizedlist>
			<listitem>
				<para><emphasis>Hibernate</emphasis></para>
			</listitem>
			<listitem>
				<para><emphasis>OpenJPA</emphasis>
				</para>
			</listitem>
			<listitem>
				<para><emphasis>EclipseLink</emphasis></para>
			</listitem>
		</itemizedlist>
	</section>
	<section id="jpa-java-implementation">
		<title>Java Implementation</title>
		<para>Each of the provided components will use the
			<classname>org.springframework.integration.jpa.core.JpaExecutor</classname>
			class which in turn will use an implementation of the
			<interfacename>org.springframework.integration.jpa.core.JpaOperations</interfacename>
			interface. <interfacename>JpaOperations</interfacename> operates like a
			typical Data Access Object (DAO) and provides methods such as
			<emphasis>find</emphasis>,
			<emphasis>persist</emphasis>,
			<emphasis>executeUpdate</emphasis> etc. For most use cases the provided
			default implementation
			<classname>org.springframework.integration.jpa.core.DefaultJpaOperations</classname>
			should be sufficient. Nevertheless, the provided components allow you to
			optionally specify your own implementation in case you require custom
			behavior.
		</para>
		<para>
			For initializing a <classname>JpaExecutor</classname>
			you have to use one of 3 available constructors that accept either a:
		</para>
		<itemizedlist>
			<listitem>
				<para><emphasis>EntityManagerFactory</emphasis></para>
			</listitem>
			<listitem>
				<para><emphasis>EntityManager</emphasis> or
				</para>
			</listitem>
			<listitem>
				<para><emphasis>JpaOperations</emphasis></para>
			</listitem>
		</itemizedlist>
		<para><emphasis>Example</emphasis></para>
		<para>
			The following example of a JPA Outbound Gateway is configured purely
			through Java. In typical usage scenarios you will most likely prefer
			the XML Namespace Support described further below. However, the example
			illustrates how the classes are wired up.
		</para>
		<para>
			First, we instantiate a <classname>JpaExecutor</classname> using an
			<interfacename>EntityManager</interfacename> as constructor argument.
			The <classname>JpaExecutor</classname> is then used as constructor argument for the
			<classname>o.s.i.jpa.outbound.JpaOutboundGateway</classname> and the
			<classname>JpaOutboundGateway</classname> will be passed as constructor
			argument in to the <classname>EventDrivenConsumer</classname>.
		</para>

		<programlisting language="xml"><![CDATA[<bean id="jpaExecutor" class="o.s.i.jpa.core.JpaExecutor">
	<constructor-arg name="entityManager" ref="entityManager"/>
	<property name="entityClass"        value="o.s.i.jpa.test.entity.StudentDomain"/>
	<property name="jpaQuery"           value="select s from Student s where s.id = :id"/>
	<property name="expectSingleResult" value="true"/>
	<property name="jpaParameters" >
		<util:list>
			<bean class="org.springframework.integration.jpa.support.JpaParameter">
				<property name="name"       value="id"/>
				<property name="expression" value="payload"/>
			</bean>
		</util:list>
	</property>
</bean>

<bean id="jpaOutboundGateway" class="o.s.i.jpa.outbound.JpaOutboundGateway">
	<constructor-arg ref="jpaExecutor"/>
	<property        name="gatewayType"   value="RETRIEVING"/>
	<property        name="outputChannel" ref="studentReplyChannel"/>
</bean>

<bean id="getStudentEndpoint"
	  class="org.springframework.integration.endpoint.EventDrivenConsumer">
	<constructor-arg name="inputChannel" ref="getStudentChannel"/>
	<constructor-arg name="handler"      ref="jpaOutboundGateway"/>
</bean>]]></programlisting>

		<para>
			When using XML Namespace Support the underlying parser classes will
			instantiate the classes for you. Thus, you typically don't have to
			deal with the inner workings but in case you need to debug the JPA
			Components of your message flow, or if you need to provide customization
			understanding it will be helpful. The following section will describe
			how to use the XML Namespace Support to configure the Jpa components.
		</para>
	</section>
	<section id="jpa-common-configuration-attributes">
		<title>Common Configuration Attributes</title>
		<para>
			Certain configuration parameters are shared amongst all JPA components and are described below:
		</para>

		<para><emphasis role="bold">auto-startup</emphasis></para>
		<para>
			Lifecycle attribute signaling if this component should
			be started during Application Context startup.
			Defaults to <code>true</code>.
			<emphasis>Optional</emphasis>.
		</para>

		<para><emphasis role="bold">id</emphasis></para>
		<para>
			Identifies the underlying Spring bean definition, which
			is an instance of either <classname>EventDrivenConsumer</classname>
			or <classname>PollingConsumer</classname>.
			<emphasis>Optional</emphasis>.
		</para>

		<para><emphasis role="bold">entity-manager-factory</emphasis></para>
		<para>
			The reference to the JPA Entity Manager Factory
			that will be used by the adapter to create the <classname>EntityManager</classname>.
			Either this attribute or the <emphasis>enity-manager</emphasis> attribute
			or the <emphasis>jpa-operations</emphasis> attribute must be provided.
		</para>

		<para><emphasis role="bold">entity-manager</emphasis></para>
		<para>
			The reference to the JPA Entity Manager that will be used by
			the component.
			Either this attribute or the <emphasis>enity-manager-factory</emphasis> attribute
			or the <emphasis>jpa-operations</emphasis> attribute must be provided.
		</para>
		<note>
			Usually your Spring Application Context only defines a
			JPA Entity Manager Factory and the EntityManager is injected using
			the @PersistenceContext annotation. This, however, is not applicable for
			the Spring Integration JPA components.

			Usually, injecting the JPA Entity Manager Factory will be best but in
			case you want to inject an EntityManager explicitly, you have to define
			a <classname>SharedEntityManagerBean</classname>. For more information,
			please see the relevant
			<ulink url="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/orm/jpa/support/SharedEntityManagerBean.html">JavaDoc</ulink>.
		</note>
		<programlisting language="xml"><![CDATA[<bean id="entityManager"
      class="org.springframework.orm.jpa.support.SharedEntityManagerBean">
    <property name="entityManagerFactory" ref="entityManagerFactoryBean" />
</bean>]]></programlisting>
		<para><emphasis role="bold">jpa-operations</emphasis></para>
		<para>
			Reference to a bean implementing the
			<interfacename>JpaOperations</interfacename> interface. In rare cases
			it might be advisable to provide your own implementation
			of the <interfacename>JpaOperations</interfacename> interface, instead
			of relying on the default implementation
			<classname>org.springframework.integration.jpa.core.DefaultJpaOperations</classname>.
			As <interfacename>JpaOperations</interfacename> wraps the necessary
			datasource; the JPA Entity Manager or JPA Entity Manager Factory
			must not be provided, if the <emphasis>jpa-operations</emphasis>
			attribute is used.
		</para>

		<para><emphasis role="bold">entity-class</emphasis></para>
		<para>
			The reference to the JPA Persistence Entity. The exact semantics of
			this attribute vary, depending on whether we are performing a persist/update
			operation or whether we are retrieving objects from the database.
		</para>
		<para>
			When retrieving data, you can specify the
			<emphasis>entity-class</emphasis> attribute to indicate that you would
			like to retrieve objects of this type from the database. In that case
			you must not define any of the query attributes (
			<emphasis>jpa-query</emphasis>,
			<emphasis>native-query</emphasis> or
			<emphasis>named-query</emphasis>
			)
		</para>
		<para>
			When persisting data, the <emphasis>entity-class</emphasis> attribute
			will indicate the type of object to persist. If not specified
			(for persist operations) the entity class will be automatically retrieved
			from the Message's payload.
		</para>

		<para><emphasis role="bold">jpa-query</emphasis></para>
		<para>
			Defines the JPA query (Java Persistence Query Language) to be used.
		</para>

		<para><emphasis role="bold">native-query</emphasis></para>
		<para>
			Defines the native SQL query to be used.
		</para>

		<para><emphasis role="bold">named-query</emphasis></para>
		<para>
			This attribute refers to a named query. A named query can
			either be defined in Native SQL or JPAQL but the underlying JPA
			persistence provider handles that distinction internally.
		</para>

	</section>

	<section id="jpa-parameters">
		<title>Providing JPA Query Parameters</title>
		<para>
			For providing parameters, the JPA Parameter XML sub-element can be used.
			It provides a mechanism to provide parameters for the queries that are
			either based on the Java Persistence Query Language (JPQL) or native SQL
			queries. Parameters can also be provided for Named Queries.
		</para>

		<para><emphasis>Expression based Parameters</emphasis></para>
		<programlisting language="xml"><![CDATA[<int-jpa:parameter expression="payload.name" name="firstName"/>]]></programlisting>

		<para><emphasis>Value based Parameters</emphasis></para>
		<programlisting language="xml"><![CDATA[<int-jpa:parameter name="name" type="java.lang.String" value="myName"/>]]></programlisting>

		<para><emphasis>Positional Parameters</emphasis></para>
		<programlisting language="xml"><![CDATA[<int-jpa:parameter expression="payload.name"/>
<int-jpa:parameter type="java.lang.Integer" value="21"/>]]></programlisting>
	</section>

	<section id="jpa-transactions">
		<title>Transaction Handling</title>
		<para>
			All JPA operations like Insert, Update and Delete require a transaction to be active whenever they are
			performed. For inbound channel adapters there is nothing special to be done, it is similar
			to the way we configure transaction managers with pollers used with other inbound channel
			adapters.The xml snippet below shows a sample where a transaction manager is configured with
			the poller used with an inbound channel adapter.
			<programlisting language="xml"><![CDATA[
	<int-jpa:inbound-channel-adapter 	channel="inboundChannelAdapterOne"
							entity-manager="em"
							auto-startup="true"
							jpa-query="select s from Student s"
							expect-single-result="true"
							delete-after-poll="true">
		<int:poller fixed-rate="2000" >
			<int:transactional propagation="REQUIRED" transaction-manager="transactionManager"/>
		</int:poller>
	</int-jpa:inbound-channel-adapter>
			]]>
			</programlisting>
			However, it may be necessary to specifically start a transaction when using an outbound channel adapter/gateway.
			If a <emphasis>DirectChannel</emphasis> is an input channel for the outbound adapter/gateway,
			and if transaction is active in the current thread of execution, the JPA operation will be
			performed in the same transaction context. We can also configure to execute this JPA operation
			in a new transaction as below.
			<programlisting language="xml"><![CDATA[	<int-jpa:outbound-gateway	request-channel="namedQueryRequestChannel"
						reply-channel="namedQueryResponseChannel"
						named-query="updateStudentByRollNumber"
						entity-manager="em"
						gateway-type="UPDATING">
			<int-jpa:parameter name="lastName" expression="payload"/>
			<int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/>]]>
		<emphasis role="bold">
		<![CDATA[	<int-jpa:transactional propagation="REQUIRES_NEW" transaction-manager="transactionManager"/>]]>
		</emphasis>
    <![CDATA[	</int-jpa:outbound-gateway>]]>
			</programlisting>
		As we can see above, the <emphasis>transactional</emphasis> sub element of the outbound gateway/adapter will be
		used to specify the transaction attributes. It is optional to define this child element if
		you have <emphasis>DirectChannel</emphasis> as an input channel to the adapter and you want the
		adapter to execute the operations in the same transaction context as the caller.
		If, however, you are using an <emphasis>ExecutorChannel</emphasis>, it is required to have the
		<emphasis>transactional</emphasis> sub element as the invoking client's transaction context is not
		propagated.
		</para>
		<note>Unlike the <emphasis>transactional</emphasis> sub element of the poller which is defined
		in the spring integration's namespace, the <emphasis>transactional</emphasis> sub element for the
		outbound gateway/adapter is	defined in the jpa namespace.
		</note>
	</section>

	<section id="jpa-outbound-channel-adapter">
		<title>Outbound Channel Adapter</title>
		<para>
			The JPA Outbound channel adapter allows you to accept messages via a
			request channel. The payload can either be used as the entity to be persisted,
			or used along with the headers in parameter expressions	for a defined JPQL query to be executed.

			In the following sub sections we shall see what those possible ways of performing
			these operations are.
		</para>
		<section>
			<title>Using an Entity Class</title>
			<para>
				The XML snippet below shows how we can use the Outbound Channel
				Adapter to persist an entity to the database.
			</para>
			<programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter channel="entityTypeChannel" ]]><co id="entityTypeChannel"/><![CDATA[
        entity-class="org.springframework.integration.jpa.test.entity.Student" ]]><co id="entityClass"/><![CDATA[
        persist-mode="PERSIST" ]]><co id="persistMode"/><![CDATA[
        entity-manager="em"/ >]]><co id="entityMgr"/></programlisting>
			<calloutlist>
				<callout arearefs="entityTypeChannel">
					<para>
						The channel over which a valid JPA entity will be
						sent to the JPA Outbound Channel Adapter.
					</para>
				</callout>
				<callout arearefs="entityClass">
					<para>
						The fully qualified name of the entity class that
						would be accepted by the adapter to be persisted
						in the database. You can actually leave off this
						attribute in most cases as the adapter can determine
						the entity class automatically from the Spring Integration
						Message payload.
					</para>
				</callout>
				<callout arearefs="persistMode">
					<para>
						The operation that needs to be done by the adapter, valid values are
						<emphasis>PERSIST</emphasis>, <emphasis>MERGE</emphasis>
						and <emphasis>DELETE</emphasis>. The default value
						is <emphasis>MERGE</emphasis>.
					</para>
				</callout>
				<callout arearefs="entityMgr">
					<para>
						The JPA entity manager to be used.
					</para>
				</callout>
			</calloutlist>
			<para>
				As we can see above these 4 attributes of the <emphasis>outbound-channel-adapter</emphasis>
				are all we need to configure it to accept entities over the input channel and process
				them to <emphasis>PERSIST</emphasis>,<emphasis>MERGE</emphasis> or <emphasis>DELETE</emphasis>
				it from the underlying data source.
			</para>
		</section>
		<section>
			<title>Using JPA Query Language (JPA QL)</title>
			<para>
				We have seen in the above sub section how to perform a <emphasis>PERSIST</emphasis> action using an entity
				We will now see how to use the outbound channel adapter which uses JPA QL (Java Persistence API Query Language)
			</para>
			<programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter channel="jpaQlChannel" ]]><co id="jpaQlInputChannel"/><![CDATA[
  jpa-query="update Student s set s.firstName = :firstName where s.rollNumber = :rollNumber" ]]><co id="jpaQlQuery"/><![CDATA[
  entity-manager="em"> ]]><co id="jpaQlEntityManager"/><![CDATA[
    <int-jpa:parameter name="firstName"  expression="payload['firstName']"/> ]]><co id="jpaQlParam"/><![CDATA[
    <int-jpa:parameter name="rollNumber" expression="payload['rollNumber']"/>
</int-jpa:outbound-channel-adapter>]]></programlisting>
                <calloutlist>
                    <callout arearefs="jpaQlInputChannel">
                        <para>
                            The input channel over which the message is being sent to the outbound
                            channel adapter
                        </para>
                    </callout>
                    <callout arearefs="jpaQlQuery">
                        <para>
                            The JPA QL that needs to be executed.This query may contain parameters that will be evaluated
                            using the <emphasis>parameter</emphasis> child tag.
                        </para>
                    </callout>
                    <callout arearefs="jpaQlEntityManager">
                        <para>
                            The entity manager used by the adapter to perform the JPA operations
                        </para>
                    </callout>
                    <callout arearefs="jpaQlParam">
                        <para>
                            This sub element, one for each parameter will be used to evaluate the value of
                            the parameter names specified in the JPA QL specified in the <emphasis>query</emphasis> attribute
                        </para>
                    </callout>
                </calloutlist>
                <para>
                    The <emphasis>parameter</emphasis> sub element accepts an attribute <emphasis>name</emphasis> which corresponds to the named parameter
                    specified in the provided JPA QL (point 2 in the above mentioned sample). The value of the parameter can either be static or can be derived
                    using an expression. The static value and the expression to derive the value is specified using
                    the <emphasis>value</emphasis> and the <emphasis>expression</emphasis> attributes respectively. These attributes
                    are mutually exclusive.
                </para>
                <para>
                    If the <emphasis>value</emphasis> attribute is specified we can provide an optional
                    <emphasis>type</emphasis> attribute. The value of this attribute is the fully qualified name of the class
                    whose value is represented by the <emphasis>value</emphasis> attribute. By default
                    the type is assumed to be a <classname>java.lang.String</classname>.
                </para>
                <programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter ... >
    <int-jpa:parameter name="level" value="2" type="java.lang.Integer"/>
    <int-jpa:parameter name="name" expression="payload['name']"/>
</int-jpa:outbound-channel-adapter>]]></programlisting>
                <para>
                    As seen in the above snippet, it is perfectly valid to use multiple <emphasis>parameter</emphasis> sub elements within an outbound channel adapter
                    tag and derive some parameters using expressions and some with static value. However, care should
                    be taken not to specify the same parameter name multiple times, and, provide one <emphasis>parameter</emphasis> sub element for
                    each named parameter specified in the JPA query. For example, we are specifying two parameters
                    <emphasis>level</emphasis> and <emphasis>name</emphasis> where <emphasis>level</emphasis> attribute is a static value of type
                    <classname>java.lang.Integer</classname>, where as the <emphasis>name</emphasis> attribute is derived from the payload of the message
                </para>
                <note>
                    Though specifying <emphasis>select</emphasis> is valid for JPA QL, it makes no sense as outbound channel adapters will not be
                    returning any result. If you want to select some values, consider using the outbound gateway instead.

                </note>
		</section>
		<section>
			<title>Using Native query</title>
              <para>
                  <para>
                      In this section we will see how to use native queries to perform the operations using
                      JPA outbound channel adapter. Using native queries is similar to using JPA QL,
                      except that the query specified here is a native database query. By choosing
                      native queries we lose the database vendor independence which we get using JPA QL.
                  </para>
                  <para>
                      One of the things we can achieve using native queries is to perform database inserts, which
                      is not possible using JPA QL (To perform inserts we send JPA entities to the channel adapter as we have seen earlier).
                      Below is a small xml fragment that demonstrates the use of native query to insert values in a table. Please note that we
                      have only mentioned the important attributes below. All other attributes like <emphasis>channel</emphasis>,
                      <emphasis>entity-manager</emphasis> and the <emphasis>parameter</emphasis> sub element has the same semantics as when we use
                      JPA QL.
                  </para>
                  <important>
                      Please be aware that named parameters may not be supported
                      by your JPA provider in conjunction with native SQL queries.
                      While they work fine using Hibernate, OpenJPA and EclipseLink
                      do NOT support them: https://issues.apache.org/jira/browse/OPENJPA-111

                      Section 3.8.12 of the JPA 2.0 spec states: "Only positional
                      parameter binding and positional access to result items may
                      be portably used for native queries."
                  </important>
                  <programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter channel="nativeQlChannel"
  native-query="insert into STUDENT_TABLE(FIRST_NAME,LAST_UPDATED) values (:lastName,:lastUpdated)" ]]><co id="nativeOutboundAdapterNativeQuery"/><![CDATA[
  entity-manager="em">
    <int-jpa:parameter name="lastName" expression="payload['updatedLastName']"/>
    <int-jpa:parameter name="lastUpdated" expression="new java.util.Date()"/>
</int-jpa:outbound-channel-adapter>]]></programlisting>
                  <calloutlist>
                      <callout arearefs="nativeOutboundAdapterNativeQuery">
                          <para>
                              The native query that will be executed by this outbound channel adapter
                          </para>
                      </callout>
                  </calloutlist>
              </para>
		</section>
		<section>
              <title>Using Named query</title>
              <para>
                  <para>
                      We will now see how to use named queries after seeing using entity, JPA QL and native query in previous sub sections.
                      Using named query is also very similar to using JPA QL or a native query, except that we specify a named query instead of a query.
                      Before we go further and see the xml fragment for the declaration of the <emphasis>outbound-channel-adapter</emphasis>, we will
                      see how named JPA named queries are defined.
                  </para>
                  <para>
                      In our case, if we have an entity called <classname>Student</classname>, then we have the following in the class to define
                      two named queries <emphasis>selectStudent</emphasis> and <emphasis>updateStudent</emphasis>. Below is a way to define
                      named queries using annotations
                  </para>

                  <programlisting language="java"><![CDATA[@Entity
@Table(name="Student")
@NamedQueries({
    @NamedQuery(name="selectStudent", query="select s from Student s where s.lastName = 'Last One'"),
    @NamedQuery(name="updateStudent", query="update Student s set s.lastName = :lastName,
                        lastUpdated = :lastUpdated where s.id in (select max(a.id) from Student a)")
})
public class Student {

...]]></programlisting>
                <para>
                    You can alternatively use the <emphasis>orm.xml</emphasis> to define named queries as seen below
                </para>
                <programlisting language="xml"><![CDATA[<entity-mappings ...>
    ...
    <named-query name="selectStudent">
        <query>select s from Student s where s.lastName = 'Last One'</query>
    </named-query>
</entity-mappings>]]></programlisting>
                <para>
                    Now that we have seen how we can define named queries using annotations or using <emphasis>orm.xml</emphasis>, we
                    will now see a small xml fragment for defining an <emphasis>outbound-channel-adapter</emphasis> using named query
                </para>
                <programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter channel="namedQueryChannel"
            named-query="updateStudent"	]]><co id="namedQuery"/><![CDATA[
            entity-manager="em">
        <int-jpa:parameter name="lastName" expression="payload['updatedLastName']"/>
        <int-jpa:parameter name="lastUpdated" expression="new java.util.Date()"/>
</int-jpa:outbound-channel-adapter>]]></programlisting>
                <calloutlist>
                    <callout arearefs="namedQuery">
                        <para>
                            The named query that we want the adapter to execute when it receives a message over the channel
                        </para>
                    </callout>
                </calloutlist>
              </para>
		</section>
          <para>
          We have now seen four possible ways of defining the <emphasis>outbound-channel-adapter</emphasis> in the previous sub sections.
          We will now see how to use outbound gateways in the next section.
          </para>
		<section id="jpaOutboundChannelAdapterParameters">
				<title>Configuration Parameter Reference</title>
				<programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter
  auto-startup="true" ]]><co id="outAdaptAutoStart"/><![CDATA[
  channel="" ]]><co id="outAdaptChannel"/><![CDATA[
  entity-class="" ]]><co id="outAdaptEntityClass"/><![CDATA[
  entity-manager="" ]]><co id="outAdaptEntityManager"/><![CDATA[
  entity-manager-factory="" ]]><co id="outAdaptEntityMgrFact"/><![CDATA[
  id=""
  jpa-operations="" ]]><co id="outAdaptJpaOperation"/><![CDATA[
  jpa-query="" ]]><co id="outAdaptJpaQuery"/><![CDATA[
  named-query="" ]]><co id="outAdaptNamedQuery"/><![CDATA[
  native-query="" ]]><co id="outAdaptNativeQuery"/><![CDATA[
  order="" ]]><co id="outAdaptOrder"/><![CDATA[
  parameter-source-factory=""  ]]><co id="outAdaptParamSourceFact"/><![CDATA[
  persist-mode="MERGE"  ]]><co id="outAdaptPersistMode"/><![CDATA[
  use-payload-as-parameter-source="true"  ]]><co id="outAdaptUserPayloadAsParamSrc"/><![CDATA[>
	<int:poller/>
	<int-jpa:transactional/>   ]]><co id="outAdaptTransactional"/><![CDATA[>
	<int-jpa:parameter/>   ]]><co id="outAdaptParam"/><![CDATA[>
</int-jpa:outbound-channel-adapter>]]></programlisting>
		<calloutlist>
			<callout arearefs="outAdaptAutoStart">
				<para>
					Lifecycle attribute signaling if this component should be started during Application Context startup. Defaults to <code>true</code>. <emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="outAdaptChannel">
				<para>
					The channel from which the outbound adapter will receive messages for performing the desired operation.
				</para>
			</callout>
			<callout arearefs="outAdaptEntityClass">
				<para>
					The fully qualified name of the entity class for the JPA Operation.
					The attributes entity-class, query and named-query are mutually exclusive. Optional
				</para>
			</callout>
			<callout arearefs="outAdaptEntityManager">
				<para>
					An instance of <classname>javax.persistence.EntityManager</classname> that will be used to perform the JPA operations. <emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="outAdaptEntityMgrFact">
				<para>
					An instance of <classname>javax.persistence.EntityManagerFactory</classname> that will be used to
					obtain an instance of <classname>javax.persistence.EntityManager</classname> that will perform the JPA operations. <emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="outAdaptJpaOperation">
				<para>
					An implementation of <classname>org.springframework.integration.jpa.core.JpaOperations</classname> that would be used to perform the JPA operations.
					It is recommended not to provide an implementation of your own but use the default
					<classname>org.springframework.integration.jpa.core.DefaultJpaOperations</classname> implementation. Either of the
					<emphasis>entity-manager</emphasis>, <emphasis>entity-manager-factory</emphasis> or
					<emphasis>jpa-operations</emphasis> attributes is to be used. <emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="outAdaptJpaQuery">
				<para>
					The JPA QL that needs to be executed by this adapter.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="outAdaptNamedQuery">
				<para>
					The named query that needs to be executed by this adapter.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="outAdaptNativeQuery">
				<para>
					The native query that will be executed by this adapter. Either of the <emphasis>jpa-query</emphasis>,
					<emphasis>named-query</emphasis> or <emphasis>native-query</emphasis> attributes are to be used. <emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="outAdaptOrder">
				<para>
					The order for this consumer when multiple consumers are registered thereby
					managing load- balancing and/or failover. Optional (Defaults to <emphasis>Ordered.LOWEST_PRECEDENCE</emphasis>).
				</para>
			</callout>
			<callout arearefs="outAdaptParamSourceFact">
				<para>
					An instance of <classname>org.springframework.integration.jpa.support.parametersource.ParameterSourceFactory</classname>
					that will be used to get an instance of <classname>org.springframework.integration.jpa.support.parametersource.ParameterSource</classname>
					which will be used to resolve the values of the parameters provided in the query.
					Ignored if operations are performed using a JPA entity. If a parameter sub element is used, the factory must be of
					type <classname>org.springframework.integration.jpa.support.parametersource.ExpressionEvaluatingParameterSourceFactory</classname>. <emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="outAdaptPersistMode">
				<para>
					Accepts one of the <emphasis>PERSIST</emphasis>,<emphasis>MERGE</emphasis> or <emphasis>DELETE</emphasis>. Indicates the operation that the adapter needs to perform.
					Relevant only if an entity is being used for JPA operations.
					Ignored if JPA QL, named query or native query is provided. Defaults to <emphasis>MERGE</emphasis>. <emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="outAdaptUserPayloadAsParamSrc">
				<para>
					If set to true, the payload of the Message will be used as a source for providing parameters.
					If false, however, the entire Message will be available as a source for parameters.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="outAdaptTransactional">
				<para>
					Defines the transaction management attributes and the reference to transaction manager to be used by the JPA
					adapter.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="outAdaptParam">
				<para>
					One or more <emphasis>parameter</emphasis> attributes, one for each parameter used in the query. The value or expression
					provided will be evaluated to compute the value of the parameter.<emphasis>Optional</emphasis>.
				</para>
			</callout>

		</calloutlist>
		</section>
	</section>
	<section id="jpa-outbound-gateway">
		<title>Outbound Gateway</title>
          <para>
              <para>
              Outbound gateways are similar to outbound channel adapter except that it can also be used to
              get a result on the <emphasis>reply channel</emphasis> after performing
              the given JPA operation . If you are directly referring to this outbound gateway section,
              we would recommend you to first go through the outbound channel adapter section given above, as most of the common concepts have been
              explained there.
              </para>
              <para>
              Simlar to the <emphasis>outbound-channel-adapter</emphasis>, we can use
              <itemizedlist>
                 <listitem>
                     <para><emphasis>Entity classes</emphasis></para>
                 </listitem>
                 <listitem>
                     <para>
                         <emphasis>JPA Query Language (JPQL)</emphasis>
                     </para>
                 </listitem>
                 <listitem>
                     <para><emphasis>Native query</emphasis></para>
                 </listitem>
                 <listitem>
                     <para><emphasis>Named query</emphasis></para>
                 </listitem>
             </itemizedlist>
             for performing various JPA operations. We will be seeing each of these in the following four sub sections. Since we are assuming
             you are already familiar with the <emphasis>outbound-channel-adapter</emphasis>, we will only discuss portions relevant to
             <emphasis>outbound-gateway</emphasis>.
              </para>
          </para>
          <section>
                  <title>Difference between <emphasis>UPDATING</emphasis> and <emphasis>RETRIEVING</emphasis> gateway</title>
                  <para>
                      Before we continue, let us see what are the types of JPA outbound gateways.
                      JPA outbound gateways are either <emphasis>UPDATING</emphasis> or <emphasis>RETRIEVING</emphasis>
                      types. The type is specified using the <emphasis>gateway-type</emphasis> attribute.
                      If this attribute is not specified, the gateway type if defaulted to an <emphasis>UPDATING</emphasis>
                      type of the gateway
                  </para>
                  <para>
                      Whenever the gateway intends to perform an action that updates or deletes some records in the
                      database using JPA, you need to use an <emphasis>UPDATING</emphasis> type of gateway. If an entity is
                      used, a merged/persisted entity is returned. In any other case
                      the number of records affected (updated or deleted) are returned.
                  </para>
                  <para>
                      If the calling application requires to  select/retrieve some data from the database
                      using <emphasis>outbound-gateway</emphasis>, we use a <emphasis>RETRIEVING</emphasis> type
                      of gateway. With a <emphasis>RETRIEVING</emphasis> type of gateway, we can use either
                      of JPA QL, Named Query or Native Query for selecting the data and retrieving the result.
                  </para>
          </section>
          <section id="outboundGatewayEntityClass">
              <title>Using Entity class</title>
              <para>
              We will see below an xml snippet that declares an <emphasis>outbound-gateway</emphasis> using
              entity class.
              </para>
              <programlisting language="xml"><![CDATA[<int-jpa:outbound-gateway	request-channel="entityRequestChannel" ]]><co id="gatewayEntityReqChannel"/><![CDATA[
    reply-channel="entityResponseChannel" ]]><co id="gatewayEntityRepChannel"/><![CDATA[
    entity-class="org.springframework.integration.jpa.test.entity.Student"
    entity-manager="em"
    gateway-type="UPDATING" ]]><co id="gatewayEntityGatewayType"/><![CDATA[/>]]></programlisting>
              <calloutlist>
                  <callout arearefs="gatewayEntityReqChannel">
                      <para>This is the request channel for the outbound gateway, this is similar
                      to the <emphasis>channel</emphasis> attribute of the <emphasis>outbound-channel-adapter</emphasis>
                      </para>
                  </callout>
                  <callout arearefs="gatewayEntityRepChannel">
                      <para>
                      This is where a gateway differs from an outbound adapter, this is the channel over
                      which the reply of the JPA operation performed is received. If,however, you are not interested in the
                      reply received and just want to perform the operation, then <emphasis>outbound-channel-adapter</emphasis>
                      is an appropriate choice. In above case, where we are using entity class, the reply will
                      be the entity object that was created/merged as a result of the JPA operation performed.</para>
                  </callout>
                  <callout arearefs="gatewayEntityGatewayType">
                      <para>
                          Valid values are <emphasis>RETRIEVING</emphasis> and <emphasis>UPDATING</emphasis>.
                          This attribute is optional and in it's absence the value
                          defaults to <emphasis>UPDATING</emphasis>.
                      </para>
                  </callout>
              </calloutlist>
          </section>

          <section id="outboundGatewayJPAQl">
              <title>Using JPA Query Language (JPA QL)</title>
              <para>
                  We will now see how we can use JPA QL in an outbound gateway. Below xml snippet is a declaration of the
                  <emphasis>outbound-gateway</emphasis>.
              </para>
              <programlisting language="xml"><![CDATA[<int-jpa:outbound-gateway	request-channel="jpaqlRequestChannel"
  reply-channel="jpaqlResponseChannel"
  jpa-query="update Student s set s.lastName = :lastName where s.rollNumber = :rollNumber" ]]><co id="jpaQlGatewayQuery"/><![CDATA[
  entity-manager="em"
  gateway-type="UPDATING">
    <int-jpa:parameter name="lastName" expression="payload"/>
    <int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/>
</int-jpa:outbound-gateway>]]></programlisting>
                  <calloutlist>
                      <callout arearefs="jpaQlGatewayQuery">
                          <para>
                              The JPA QL that will be executed by the gateway. Since the
                              <emphasis>gateway-type</emphasis> is <emphasis>UPDATING</emphasis>, only <emphasis>update</emphasis> and
                              <emphasis>delete</emphasis> JPA QL will be acceptable.
                          </para>
                      </callout>
                  </calloutlist>
                  <para>
                      On sending a message with string payload and containing a header <emphasis>rollNumber</emphasis>
                      with a <emphasis>long</emphasis> value, the last name of the student with the provided roll number
                      is updated to the value provided in the message payload. When using a gateway of type
                      <emphasis>UPDATING</emphasis>, the return value is <emphasis>always</emphasis> an integer
                      value which denotes the number of records affected by execution of the JPA QL.
                  </para>
                  <para>
					The following is a sample <emphasis>RETRIEVING</emphasis> type of an outbound gateway below.
<programlisting language="xml">
<![CDATA[<int-jpa:outbound-gateway request-channel="retrievingGatewayReqChannel"
			reply-channel="retrievingGatewayReplyChannel"
			jpa-query="select s from Student s where s.firstName = :firstName and s.lastName = :lastName"
			gateway-type="RETRIEVING"
			entity-manager="em">
		<int-jpa:parameter name="firstName" expression="payload"/>
		<int-jpa:parameter name="lastName" expression="headers['lastName']"/>
	</int-jpa:outbound-gateway>]]>
</programlisting>
				The above sample is pretty straightforward and simple. The gateway type if
				<emphasis>RETRIEVING</emphasis> and the <emphasis>jpa-query</emphasis> is a select query.
                  </para>
          </section>
          <section id="outboundGatewayNativeQuery">
              <title>Using Native query</title>
              <para>
	              Using a native query is similar to using the JPA QL except that the <emphasis>jpa-query</emphasis> attribute is now
	              replaced by the <emphasis>native-query</emphasis> attribute which holds the native query to execute.
              </para>
          </section>
          <section id="outboundGatewayNamedQuery">
              <title>Using Named query</title>
              <para>
                  Using named query is also very similar to using a JPA QL except that we have
                  the <emphasis>named-query</emphasis> attribute as seen in the xml snippet below
              </para>
              <programlisting language="xml"><![CDATA[<int-jpa:outbound-gateway request-channel="namedQueryRequestChannel"
                reply-channel="namedQueryResponseChannel"
                named-query="updateStudentByRollNumber"
                entity-manager="em"
                gateway-type="UPDATING">
    <int-jpa:parameter name="lastName" expression="payload"/>
    <int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/>
</int-jpa:outbound-gateway>]]></programlisting>
		</section>

			<section id="jpaOutboundGatewayParameters">
				<title>Configuration Parameter Reference</title>
				<para>The following shows various attributes that can be used for the JPA outbound gateway
				Only the attributes which are different than those explained earlier are mentioned here.
				</para>
				<programlisting language="xml"><![CDATA[<int-jpa:outbound-gateway request-channel=""
  auto-startup="true"
  entity-class=""
  entity-manager=""
  entity-manager-factory=""
  expect-single-result="false" ]]><co id="outGateExpectSingleResult"/><![CDATA[
  gateway-type="UPDATING" ]]><co id="outGateGatewayType"/><![CDATA[
  id=""
  jpa-operations=""
  jpa-query=""
  max-number-of-results="" ]]><co id="outGateMaxNumOfResults"/><![CDATA[
  named-query=""
  native-query=""
  order=""
  parameter-source-factory=""
  persist-mode="MERGE"
  reply-channel="" ]]><co id="outGateReplyChannel"/><![CDATA[
  reply-timeout="" ]]><co id="outGateReplyTimeout"/><![CDATA[
  request-channel="" ]]><co id="outGateRequestChannel"/><![CDATA[
  use-payload-as-parameter-source="true">
  <int:poller></int:poller>
  <int-jpa:transactional transaction-manager="transactionManager"/>
  <int-jpa:parameter expression="" name="" type="" value=""/>
</int-jpa:outbound-gateway>]]></programlisting>
<calloutlist>
	<callout arearefs="outGateExpectSingleResult">
		<para>
			A boolean flag indicating whether the select operation is expected to return a single result or a <classname>List</classname> of results.
			If this flag is set to <code>true</code>, the single entity selected is sent as the payload
			of the message. If multiple entities are returned, an exception is thrown.
			If <code>false</code>, the <classname>List</classname> of entities is being sent as the payload of the message.
			By default the value is <code>false</code>.<emphasis>Optional</emphasis>.
		</para>
	</callout>
	<callout arearefs="outGateGatewayType">
		<para>
			Valid values are <emphasis>UPDATING</emphasis> and <emphasis>RETRIEVING</emphasis>,
			the value defaults to <emphasis>UPDATING</emphasis>.
			The difference between these types of gateways is explained earlier in the manual.<emphasis>Optional</emphasis>.
		</para>
	</callout>
	<callout arearefs="outGateMaxNumOfResults">
		<para>
			This non zero, non negative integer value tells the adapter not to select more than given number
			of rows on execution of the select operation. By default, if this attribute is not set,
			all the possible records are selected by given query.<emphasis>Optional</emphasis>.
		</para>
	</callout>
	<callout arearefs="outGateReplyChannel">
		<para>
			The channel to which the gateway will send the response after performing the required JPA operation.
			If this attribute is not defined, the request message must have a replyChannel header. <emphasis>Optional</emphasis>.
		</para>
	</callout>
	<callout arearefs="outGateReplyTimeout">
		<para>
			Specifies the time the gateway will wait to send the result to the reply channel.
			Only applies when the reply channel itself might block the send (for example a bounded QueueChannel that is currently full).
			By default the Gateway will wait indefinitely. The value is specified in milliseconds. <emphasis>Optional</emphasis>.
		</para>
	</callout>
	<callout arearefs="outGateRequestChannel">
		<para>
			The channel from which the outbound gateway will receive messages for performing
			the desired operation. This attribute is similar to <emphasis>channel</emphasis> attribute of the outbound-channel-adapter.<emphasis>Optional</emphasis>.
		</para>
	</callout>
</calloutlist>
		</section>
	</section>
	<section id="jpa-inbound-channel-adapter">
         <title>Inbound Channel Adapter</title>
          <para>
              An inbound channel adapter is used to execute a <emphasis>select</emphasis> query over the
              database using JPA QL and return the result. The message payload will be either a single
              entity or a <code>List</code> of entities. Below is a sample xml snippet that shows
              a sample usage of <emphasis>inbound-channel-adapter</emphasis>.
          </para>
          <programlisting language="xml"><![CDATA[<int-jpa:inbound-channel-adapter channel="inboundChannelAdapterOne" ]]><co id="inboundAdapterChannel"/><![CDATA[
                    entity-manager="em" ]]><co id="inboundAdapterEntityManager"/><![CDATA[
                    auto-startup="true" ]]><co id="inboundAdapterAutoStartup"/><![CDATA[
                    query="select s from Student s" ]]><co id="inboundAdapterQuery"/><![CDATA[
                    expect-single-result="true" ]]><co id="inboundAdapterExpectResult"/><![CDATA[
                    delete-after-poll="true"> ]]><co id="inboundAdapterDeleteAfterPoll"/><![CDATA[
    <int:poller fixed-rate="2000" >
      <int:transactional propagation="REQUIRED" transaction-manager="transactionManager"/>
    </int:poller>
</int-jpa:inbound-channel-adapter>]]>
              </programlisting>
              <calloutlist>
                  <callout arearefs="inboundAdapterChannel">
                      <para>
                          The channel over which the <emphasis>inbound-channel-adapter</emphasis> will put the
                          messages with the payload received after executing the provided JPA QL in the
                          <emphasis>query</emphasis> attribute.
                      </para>
                  </callout>
                  <callout arearefs="inboundAdapterEntityManager">
                      <para>
                          The <classname>EntityManager</classname> instance that will be used to perform the
                          required JPA operations.
                      </para>
                  </callout>
                  <callout arearefs="inboundAdapterAutoStartup">
                      <para>
                          Attribute signalling if the component should be automatically started on startup of
                          the Application Context. The value defaults to <code>true</code>
                      </para>
                  </callout>
                  <callout arearefs="inboundAdapterQuery">
                      <para>
                          The JPA QL that needs to be executed and whose result needs to be sent out as the
                          payload of the message
                      </para>
                  </callout>
                  <callout arearefs="inboundAdapterExpectResult">
                      <para>
                          The attribute that tells if the executed JPA QL gives a single entity in the result
                          or a <classname>List</classname> of entities. If the value is set to <code>true</code>,
                          the single entity retrieved is sent as the payload of the message. If, however, multiple
                          results are returned after setting this to <code>true</code>, a
                          <classname>MessageHandlingException</classname> is thrown. The value defaults to <code>false</code>
                      </para>
                  </callout>
                  <callout arearefs="inboundAdapterDeleteAfterPoll">
                      <para>
                          Set this value to <code>true</code> if you want
                          to delete the rows received after execution of the query.
                          Please ensure that the component is operating as part
                          of a transaction.

                          Otherwise, you may encounter an Exception such as:
                          <emphasis>java.lang.IllegalArgumentException: Removing
                          a detached instance ...</emphasis>
                      </para>
                  </callout>
              </calloutlist>
		<section id="jpaInboundChannelAdapterParameters">
			<title>Configuration Parameter Reference</title>
			<programlisting language="xml"><![CDATA[<int-jpa:inbound-channel-adapter
  auto-startup="true" ]]><co id="inAdaptAutoStart"/><![CDATA[
  channel="" ]]><co id="inAdaptChannel"/><![CDATA[
  delete-after-poll="false"  ]]><co id="inAdaptDelAftPoll"/><![CDATA[
  delete-per-row="false"  ]]><co id="inAdaptDelPerRow"/><![CDATA[
  entity-class=""  ]]><co id="inAdaptEntityClass"/><![CDATA[
  entity-manager="" ]]><co id="inAdaptEntityMgr"/><![CDATA[
  entity-manager-factory="" ]]><co id="inAdaptEntityMgrFact"/><![CDATA[
  expect-single-result="false" ]]><co id="inAdaptExpectSingleResult"/><![CDATA[
  id=""
  jpa-operations="" ]]><co id="inAdaptJpaOperation"/><![CDATA[
  jpa-query="" ]]><co id="inAdaptJpaQuery"/><![CDATA[
  named-query="" ]]><co id="inAdaptNamedQuery"/><![CDATA[
  native-query="" ]]><co id="inAdaptNativeQuery"/><![CDATA[
  parameter-source="" ]]><co id="inAdaptParamSource"/><![CDATA[
  send-timeout="" ]]><co id="inAdaptSendTimeout"/><![CDATA[>
  <int:poller ref="myPoller"/>
 </int-jpa:inbound-channel-adapter>]]></programlisting>
		</section>
		<calloutlist>
			<callout arearefs="inAdaptAutoStart">
				<para>
					This <emphasis>Lifecycle</emphasis> attribute signaled if this component should be started during startup of the Application Context.
					This attribute defaults to true.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptChannel">
				<para>
					The channel to which the adapter will send a message with the payload that was received after
					performing the desired JPA operation.
				</para>
			</callout>
			<callout arearefs="inAdaptDelAftPoll">
				<para>
					A boolean flag that indicates whether the records selected are to be deleted
					after they are being polled by the adapter. By default the value is <code>false</code>,
					that is, the records will not be deleted. Please ensure that the component is operating as part of a transaction.
					Otherwise, you may encounter an Exception such as:
					<emphasis>java.lang.IllegalArgumentException: Removing a detached instance ...</emphasis>.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptDelPerRow">
				<para>
					A boolean flag that indicates whether the records can be deleted in bulk or are deleted
					one record at a time. By default the value is <code>false</code>, that is, the records are bulk deleted.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptEntityClass">
				<para>
					The fully qualified name of the entity class that would be queried from the database. The adapter will automatically
					build a JPA Query to be executed based on the entity class name provided.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptEntityMgr">
				<para>
					An instance of <classname>javax.persistence.EntityManager</classname> that will be used to perform the JPA operations. <emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptEntityMgrFact">
				<para>
					An instance of <classname>javax.persistence.EntityManagerFactory</classname> that will be used to obtain
					an instance of <classname>javax.persistence.EntityManager</classname> that will perform the JPA operations. <emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptExpectSingleResult">
				<para>
					A boolean flag indicating whether the select operation is expected to return a single result or a <classname>List</classname> of results.
					If this flag is set to <code>true</code>, the single entity selected is sent as the payload
					of the message. If multiple entities are returned, an exception is thrown.
					If <code>false</code>, the <classname>List</classname> of entities is being sent as the payload of the message.
					By default the value is <code>false</code>.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptJpaOperation">
				<para>
					An implementation of <classname>org.springframework.integration.jpa.core.JpaOperations</classname> that would be used to perform the JPA operations.
					It is recommended not to provide an implementation of your own but use the default
					<classname>org.springframework.integration.jpa.core.DefaultJpaOperations</classname> implementation. Either of the
					<emphasis>entity-manager</emphasis>, <emphasis>entity-manager-factory</emphasis> or
					<emphasis>jpa-operations</emphasis> attributes is to be used. <emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptJpaQuery">
				<para>
					The JPA QL that needs to be executed by this adapter.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptNamedQuery">
				<para>
					The named query that needs to be executed by this adapter.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptNativeQuery">
				<para>
					The native query that will be executed by this adapter. Either of the <emphasis>jpa-query</emphasis>,
					<emphasis>named-query</emphasis>,<emphasis>entity-class</emphasis> or <emphasis>native-query</emphasis>
					attributes are to be used. <emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptParamSource">
				<para>
					An implementation of <classname>org.springframework.integration.jpa.support.parametersource.ParameterSource</classname>
					which will be used to resolve the values of the parameters provided in the query. Ignored if <emphasis>entity-class</emphasis>
					attribute is provided.<emphasis>Optional</emphasis>.
				</para>
			</callout>
			<callout arearefs="inAdaptSendTimeout">
				<para>
					Maximum amount of time in milliseconds to wait when sending a message to the channel.<emphasis>Optional</emphasis>.
				</para>
			</callout>
		</calloutlist>
	</section>
	<note>
		<para>You can find more samples for using spring integration's JPA adapter at:</para>
		<para><ulink url="https://github.com/SpringSource/spring-integration-samples/tree/master/basic/jpa">https://github.com/SpringSource/spring-integration-samples/tree/master/basic/jpa</ulink></para>
	</note>
</chapter>