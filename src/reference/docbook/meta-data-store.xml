<?xml version="1.0" encoding="UTF-8"?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="metadata-store"
		 xmlns:xlink="http://www.w3.org/1999/xlink">
	<title>Metadata Store</title>
	<para>
		Many external systems, services or resources aren't transactional (Twitter, RSS, file system etc.)
		and with them there is no any ability to mark the data as readed. Or there is just need to implement
		Enterprise Integration Pattern <ulink url="http://eaipatterns.com/IdempotentReceiver.html">Idempotent Receiver</ulink>
		in some integration solutions. To achieve this goal and store some previous state of the Endpoint before the next
		interaction with external system or get deal with next Message, Spring Integration provides <emphasis>Metadata Store</emphasis>
		component as implementation of <interfacename>org.springframework.integration.metadata.MetadataStore</interfacename>
		interface with <emphasis>key-value</emphasis> contract.
	</para>
	<para>
		The <emphasis>Metadata Store</emphasis> is designed to store various types of generic meta-data
		(e.g., published date of the last feed entry that has been processed) to help components such as this Feed adapter deal with duplicates.
		The default rule for locating this metadata store is as follows: Component will look for a bean with id
		<code>metadataStore</code> in the ApplicationContext. If one is found then it will be used, otherwise
		it will create a new instance of <classname>SimpleMetadataStore</classname> which is an in-memory implementation
		that will only persist metadata within the lifecycle of the currently running Application Context. This means
		that upon restart you may end up with duplicate entries.
	</para>
	<para>
		If you need to persist metadata between Application Context restarts, two
		persistent <interfacename>MetadataStores</interfacename> are available:
	</para>
	<itemizedlist>
		<listitem>PropertiesPersistingMetadataStore</listitem>
		<listitem><xref linkend="redis-metadata-store"/></listitem>
	</itemizedlist>
	<para>
		The <classname>PropertiesPersistingMetadataStore</classname> is backed by a properties file and a
		<interfacename><ulink url="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/PropertiesPersister.html">PropertiesPersister</ulink></interfacename>.
	</para>
	<programlisting language="xml"><![CDATA[<bean id="metadataStore"
    class="org.springframework.integration.store.PropertiesPersistingMetadataStore"/>]]></programlisting>
	<para>
		Alternatively, you could provide your own implementation of the
		<interfacename>MetadataStore</interfacename> interface (e.g. JdbcMetadataStore)
		and configure it as bean in the Application Context.
	</para>
	<section id="idempotent-receiver">
		<title>Idempotent Receiver</title>
		<para>
			The <emphasis>Metadata Store</emphasis> is useful in case of implementation
			EIP <ulink url="http://eaipatterns.com/IdempotentReceiver.html">Idempotent Receiver</ulink>, when
			there is need to <emphasis>filter</emphasis> incoming Messages by some business requirement and just discard
			them or do some other logic on discarding. For this purpose it's just enough to have a configuration like this:
		</para>
		<programlisting language="xml"><![CDATA[<int:filter input-channel="serviceChannel"
			output-channel="idempotentServiceChannel"
			discard-channel="discardChannel"
			expression="@metadataStore.get(headers.businessKey) == null"/>

<int:publish-subscribe-channel id="idempotentServiceChannel"/>

<int:outbound-channel-adapter channel="idempotentServiceChannel"
                              expression="@metadataStore.put(headers.businessKey, '')"/>

<int:service-activator input-channel="idempotentServiceChannel" ref="service"/>]]></programlisting>
		<para>
			The <code>value</code> of idempotent entry maybe some expiration date, after which that entry should
			be removed from <emphasis>Metadata Store</emphasis> by some scheduled reaper.
		</para>
	</section>

</section>
